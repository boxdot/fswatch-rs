/* automatically generated by rust-bindgen */

#![allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]

pub const FSW_INVALID_HANDLE: i32 = -1;
pub const FSW_OK: u32 = 0;
pub const FSW_ERR_UNKNOWN_ERROR: u32 = 1;
pub const FSW_ERR_SESSION_UNKNOWN: u32 = 2;
pub const FSW_ERR_MONITOR_ALREADY_EXISTS: u32 = 4;
pub const FSW_ERR_MEMORY: u32 = 8;
pub const FSW_ERR_UNKNOWN_MONITOR_TYPE: u32 = 16;
pub const FSW_ERR_CALLBACK_NOT_SET: u32 = 32;
pub const FSW_ERR_PATHS_NOT_SET: u32 = 64;
pub const FSW_ERR_MISSING_CONTEXT: u32 = 128;
pub const FSW_ERR_INVALID_PATH: u32 = 256;
pub const FSW_ERR_INVALID_CALLBACK: u32 = 512;
pub const FSW_ERR_INVALID_LATENCY: u32 = 1024;
pub const FSW_ERR_INVALID_REGEX: u32 = 2048;
pub const FSW_ERR_MONITOR_ALREADY_RUNNING: u32 = 4096;
pub const FSW_ERR_UNKNOWN_VALUE: u32 = 8192;
pub const FSW_ERR_INVALID_PROPERTY: u32 = 16384;
#[doc = " @brief Opaque type representing a monitoring session."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSW_SESSION {
    _unused: [u8; 0],
}
#[doc = " @brief Handle to a monitoring session."]
pub type FSW_HANDLE = *mut FSW_SESSION;
#[doc = " @brief Status of a library call."]
pub type FSW_STATUS = ::std::os::raw::c_int;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type time_t = __darwin_time_t;
#[doc = "< No event has occurred."]
pub const fsw_event_flag_NoOp: fsw_event_flag = 0;
#[doc = "< Platform-specific placeholder for event type that cannot currently be mapped."]
pub const fsw_event_flag_PlatformSpecific: fsw_event_flag = 1;
#[doc = "< An object was created."]
pub const fsw_event_flag_Created: fsw_event_flag = 2;
#[doc = "< An object was updated."]
pub const fsw_event_flag_Updated: fsw_event_flag = 4;
#[doc = "< An object was removed."]
pub const fsw_event_flag_Removed: fsw_event_flag = 8;
#[doc = "< An object was renamed."]
pub const fsw_event_flag_Renamed: fsw_event_flag = 16;
#[doc = "< The owner of an object was modified."]
pub const fsw_event_flag_OwnerModified: fsw_event_flag = 32;
#[doc = "< The attributes of an object were modified."]
pub const fsw_event_flag_AttributeModified: fsw_event_flag = 64;
#[doc = "< An object was moved from this location."]
pub const fsw_event_flag_MovedFrom: fsw_event_flag = 128;
#[doc = "< An object was moved to this location."]
pub const fsw_event_flag_MovedTo: fsw_event_flag = 256;
#[doc = "< The object is a file."]
pub const fsw_event_flag_IsFile: fsw_event_flag = 512;
#[doc = "< The object is a directory."]
pub const fsw_event_flag_IsDir: fsw_event_flag = 1024;
#[doc = "< The object is a symbolic link."]
pub const fsw_event_flag_IsSymLink: fsw_event_flag = 2048;
#[doc = "< The link count of an object has changed."]
pub const fsw_event_flag_Link: fsw_event_flag = 4096;
#[doc = "< The event queue has overflowed."]
pub const fsw_event_flag_Overflow: fsw_event_flag = 8192;
#[doc = " @brief Backend-agnostic change flags."]
#[doc = ""]
#[doc = " Each element of this enum represents a backend-agnostic change flag.  No"]
#[doc = " direct mapping to backend-specific change types is guaranteed to exist: a"]
#[doc = " change type may be mapped to multiple `fsw_event_flag` instances included"]
#[doc = " the `PlatformSpecific` flag."]
#[doc = ""]
#[doc = " The values of event flags are all powers of 2, that is numbers @f$f=2^n@f$"]
#[doc = " where @f$n@f$ is an integer.  This representation makes it easy to combine"]
#[doc = " flags into a bit mask and encode multiple events flags into a single integer."]
#[doc = ""]
#[doc = " A monitor implementation is required to map implementation-specific flags"]
#[doc = " into API flags.  Sometimes, though, a perfect match is not possible and the"]
#[doc = " following situation may arise:"]
#[doc = ""]
#[doc = "   - One platform-specific flag must be mapped into multiple API flags."]
#[doc = ""]
#[doc = "   - Multiple platform-specific flags must be mapped into a single API flag."]
#[doc = ""]
#[doc = "   - A mapping is not possible for some flags, in which case they should be"]
#[doc = "     mapped to fsw_event_flag::PlatformSpecific.  The API currently offers no"]
#[doc = "     way to retain a platform-specific event flag value in this case."]
pub type fsw_event_flag = u32;
extern "C" {
    pub static mut FSW_ALL_EVENT_FLAGS: [fsw_event_flag; 15usize];
}
extern "C" {
    #[doc = " @brief Get event flag by name."]
    #[doc = ""]
    #[doc = " This function looks for an event flag called @p name and, if it exists, it"]
    #[doc = " writes its value onto @p flag and @c FSW_OK, otherwise @p flag is not"]
    #[doc = " modified and @c FSW_ERR_UNKNOWN_VALUE is returned."]
    #[doc = ""]
    #[doc = " @param[in] name The name of the event flag to look for."]
    #[doc = " @param[out] flag The output variable where the event flag is returned."]
    #[doc = " @return #FSW_OK if the functions succeeds, #FSW_ERR_UNKNOWN_VALUE"]
    #[doc = " otherwise."]
    pub fn fsw_get_event_flag_by_name(
        name: *const ::std::os::raw::c_char,
        flag: *mut fsw_event_flag,
    ) -> FSW_STATUS;
}
extern "C" {
    #[doc = " @brief Get the name of an event flag."]
    #[doc = ""]
    #[doc = " This function looks for the name of the specified event @p flag.  If it"]
    #[doc = " exists, it returns its name, otherwise @c nullptr is returned."]
    #[doc = ""]
    #[doc = " @param[in] flag The event flag to look for."]
    #[doc = " @return The name of @p flag, or @c nullptr if it does not exist."]
    pub fn fsw_get_event_flag_name(flag: fsw_event_flag) -> *mut ::std::os::raw::c_char;
}
#[doc = " A file change event is represented as an instance of this struct where:"]
#[doc = "   - path is the path where the event was triggered."]
#[doc = "   - evt_time the time when the event was triggered."]
#[doc = "   - flags is an array of fsw_event_flag of size flags_num."]
#[doc = "   - flags_num is the size of the flags array."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fsw_cevent {
    pub path: *mut ::std::os::raw::c_char,
    pub evt_time: time_t,
    pub flags: *mut fsw_event_flag,
    pub flags_num: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_fsw_cevent() {
    assert_eq!(
        ::std::mem::size_of::<fsw_cevent>(),
        32usize,
        concat!("Size of: ", stringify!(fsw_cevent))
    );
    assert_eq!(
        ::std::mem::align_of::<fsw_cevent>(),
        8usize,
        concat!("Alignment of ", stringify!(fsw_cevent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fsw_cevent>())).path as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fsw_cevent),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fsw_cevent>())).evt_time as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fsw_cevent),
            "::",
            stringify!(evt_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fsw_cevent>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fsw_cevent),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fsw_cevent>())).flags_num as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fsw_cevent),
            "::",
            stringify!(flags_num)
        )
    );
}
#[doc = " A function pointer of type FSW_CEVENT_CALLBACK is used by the API as a"]
#[doc = " callback to provide information about received events.  The callback is"]
#[doc = " passed the following arguments:"]
#[doc = "   - events, a const pointer to an array of events of type const fsw_cevent."]
#[doc = "   - event_num, the size of the *events array."]
#[doc = "   - data, optional persisted data for a callback."]
#[doc = ""]
#[doc = " The memory used by the fsw_cevent objects will be freed at the end of the"]
#[doc = " callback invocation.  A callback should copy such data instead of storing"]
#[doc = " a pointer to it."]
pub type FSW_CEVENT_CALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        events: *const fsw_cevent,
        event_num: ::std::os::raw::c_uint,
        data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = "< System default monitor."]
pub const fsw_monitor_type_system_default_monitor_type: fsw_monitor_type = 0;
#[doc = "< OS X FSEvents monitor."]
pub const fsw_monitor_type_fsevents_monitor_type: fsw_monitor_type = 1;
#[doc = "< BSD `kqueue` monitor."]
pub const fsw_monitor_type_kqueue_monitor_type: fsw_monitor_type = 2;
#[doc = "< Linux `inotify` monitor."]
pub const fsw_monitor_type_inotify_monitor_type: fsw_monitor_type = 3;
#[doc = "< Windows monitor."]
pub const fsw_monitor_type_windows_monitor_type: fsw_monitor_type = 4;
#[doc = "< `stat()`-based poll monitor."]
pub const fsw_monitor_type_poll_monitor_type: fsw_monitor_type = 5;
#[doc = "< Solaris/Illumos monitor."]
pub const fsw_monitor_type_fen_monitor_type: fsw_monitor_type = 6;
#[doc = " @brief Available monitors."]
#[doc = ""]
#[doc = " This enumeration lists all the available monitors, where the special"]
#[doc = " ::system_default_monitor_type element refers to the platform-specific"]
#[doc = " default monitor."]
pub type fsw_monitor_type = u32;
pub const fsw_filter_type_filter_include: fsw_filter_type = 0;
pub const fsw_filter_type_filter_exclude: fsw_filter_type = 1;
#[doc = " @brief Event filter type."]
pub type fsw_filter_type = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fsw_cmonitor_filter {
    pub text: *mut ::std::os::raw::c_char,
    pub type_: fsw_filter_type,
    pub case_sensitive: bool,
    pub extended: bool,
}
#[test]
fn bindgen_test_layout_fsw_cmonitor_filter() {
    assert_eq!(
        ::std::mem::size_of::<fsw_cmonitor_filter>(),
        16usize,
        concat!("Size of: ", stringify!(fsw_cmonitor_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<fsw_cmonitor_filter>(),
        8usize,
        concat!("Alignment of ", stringify!(fsw_cmonitor_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fsw_cmonitor_filter>())).text as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fsw_cmonitor_filter),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fsw_cmonitor_filter>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fsw_cmonitor_filter),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fsw_cmonitor_filter>())).case_sensitive as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(fsw_cmonitor_filter),
            "::",
            stringify!(case_sensitive)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fsw_cmonitor_filter>())).extended as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(fsw_cmonitor_filter),
            "::",
            stringify!(extended)
        )
    );
}
#[doc = " @brief Event type filter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fsw_event_type_filter {
    pub flag: fsw_event_flag,
}
#[test]
fn bindgen_test_layout_fsw_event_type_filter() {
    assert_eq!(
        ::std::mem::size_of::<fsw_event_type_filter>(),
        4usize,
        concat!("Size of: ", stringify!(fsw_event_type_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<fsw_event_type_filter>(),
        4usize,
        concat!("Alignment of ", stringify!(fsw_event_type_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fsw_event_type_filter>())).flag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fsw_event_type_filter),
            "::",
            stringify!(flag)
        )
    );
}
extern "C" {
    #[doc = " This function initializes the `libfswatch` library and must be invoked"]
    #[doc = " before any other calls to the C or C++ API.  If the function succeeds, it"]
    #[doc = " returns FSW_OK, otherwise the initialization routine failed and the library"]
    #[doc = " should not be usable."]
    pub fn fsw_init_library() -> FSW_STATUS;
}
extern "C" {
    #[doc = " This function creates a new monitor session using the specified monitor"]
    #[doc = " and returns an handle to it.  This function is the `libfswatch` API entry"]
    #[doc = " point."]
    #[doc = ""]
    #[doc = " @see cmonitor.h for a list of all the available monitors."]
    pub fn fsw_init_session(type_: fsw_monitor_type) -> FSW_HANDLE;
}
extern "C" {
    #[doc = " Adds a path to watch to the specified session.  At least one path must be"]
    #[doc = " added to the current session in order for it to be valid."]
    pub fn fsw_add_path(handle: FSW_HANDLE, path: *const ::std::os::raw::c_char) -> FSW_STATUS;
}
extern "C" {
    #[doc = " Adds the specified monitor property."]
    pub fn fsw_add_property(
        handle: FSW_HANDLE,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> FSW_STATUS;
}
extern "C" {
    #[doc = " Sets the allow overflow flag of the monitor.  When this flag is set, a"]
    #[doc = " monitor is allowed to overflow and report it as a change event."]
    pub fn fsw_set_allow_overflow(handle: FSW_HANDLE, allow_overflow: bool) -> FSW_STATUS;
}
extern "C" {
    #[doc = " Sets the callback the monitor invokes when some events are received.  The"]
    #[doc = " callback must be set in the current session in order for it to be valid."]
    #[doc = ""]
    #[doc = " See cevent.h for the definition of FSW_CEVENT_CALLBACK."]
    pub fn fsw_set_callback(
        handle: FSW_HANDLE,
        callback: FSW_CEVENT_CALLBACK,
        data: *mut ::std::os::raw::c_void,
    ) -> FSW_STATUS;
}
extern "C" {
    #[doc = " Sets the latency of the monitor.  By default, the latency is set to 1 s."]
    pub fn fsw_set_latency(handle: FSW_HANDLE, latency: f64) -> FSW_STATUS;
}
extern "C" {
    #[doc = " Determines whether the monitor recursively scans each watched path or not."]
    #[doc = " Recursive scanning is an optional feature which could not be implemented"]
    #[doc = " by all the monitors.  By default, recursive scanning is disabled."]
    pub fn fsw_set_recursive(handle: FSW_HANDLE, recursive: bool) -> FSW_STATUS;
}
extern "C" {
    #[doc = " Determines whether the monitor only watches a directory when performing a"]
    #[doc = " recursive scan.  By default, a monitor accepts all kinds of files."]
    pub fn fsw_set_directory_only(handle: FSW_HANDLE, directory_only: bool) -> FSW_STATUS;
}
extern "C" {
    #[doc = " Determines whether a symbolic link is followed or not.  By default, a"]
    #[doc = " symbolic link are not followed."]
    pub fn fsw_set_follow_symlinks(handle: FSW_HANDLE, follow_symlinks: bool) -> FSW_STATUS;
}
extern "C" {
    #[doc = " Adds an event type filter to the current session."]
    #[doc = ""]
    #[doc = " See cfilter.h for the definition of fsw_event_type_filter."]
    pub fn fsw_add_event_type_filter(
        handle: FSW_HANDLE,
        event_type: fsw_event_type_filter,
    ) -> FSW_STATUS;
}
extern "C" {
    #[doc = " Adds a filter to the current session.  A filter is a regular expression"]
    #[doc = " that, depending on whether the filter type is exclusion or not, must or"]
    #[doc = " must not be matched for an event path for the event to be accepted."]
    #[doc = ""]
    #[doc = " See cfilter.h for the definition of fsw_cmonitor_filter."]
    pub fn fsw_add_filter(handle: FSW_HANDLE, filter: fsw_cmonitor_filter) -> FSW_STATUS;
}
extern "C" {
    #[doc = " Starts the monitor if it is properly configured.  Depending on the type of"]
    #[doc = " monitor this call might return when a monitor is stopped or not."]
    pub fn fsw_start_monitor(handle: FSW_HANDLE) -> FSW_STATUS;
}
extern "C" {
    #[doc = " Stops a running monitor."]
    pub fn fsw_stop_monitor(handle: FSW_HANDLE) -> FSW_STATUS;
}
extern "C" {
    #[doc = " Checks if a monitor exists and is running."]
    pub fn fsw_is_running(handle: FSW_HANDLE) -> bool;
}
extern "C" {
    #[doc = " Destroys an existing session and invalidates its handle."]
    pub fn fsw_destroy_session(handle: FSW_HANDLE) -> FSW_STATUS;
}
extern "C" {
    #[doc = " Gets the last error code."]
    pub fn fsw_last_error() -> FSW_STATUS;
}
extern "C" {
    #[doc = " Check whether the verbose mode is active."]
    pub fn fsw_is_verbose() -> bool;
}
extern "C" {
    #[doc = " Set the verbose mode."]
    pub fn fsw_set_verbose(verbose: bool);
}
